---
title: 共享库的组织
date: 2020-07-07 15:57:32
tags:
  - 程序编译
categories:
  - 编译、链接、装载和库
keywords: 程序编译
description: 本文介绍Linux下共享库的版本等信息
sticky: 0
---


#  **共享库版本**

1. 兼容性
  兼容更新：所有更新只是在原有的基础上添加或修改一些内容，所有接口都保持不变。
  不兼容更新：改变了原有的接口，使用该共享库原有接口的程序可能不能正常运行。

  导致不兼容的有以下几种情况：
  + 导出函数的行为（功能）发生变化
  + 导出函数被删除
  + 导出数据的结构发生变化，例如结构体中成员类型、顺序变化
  + 导出函数的接口变化，例如参数和返回值

2. 命名
  规则如下：
  `libname.so.x.y.z`
  + 前缀lib，后缀so，name为库的名字，后面三个数字为版本号
  + x为主版本号：表示库的重大升级，不同主版本号的库之间是不兼容的
  + y为次版本号：表示库的增量升级，即增加一些新的符号，且保持原来的符号不变，在主版本号相同的情况下，高的次版本号向后兼容
  + z为发布版本号：表示库的错误的修正、性能的改进等，并不添加任何新的接口，也不对接口进行更改，相同主、次版本号的共享库，不同的发布版本号之间完全兼容

  > Glibc并没有遵守这个规则，而是libc-x.y.z.so

3. SO-NAME
  采用SO-NAME的命名机制来记录共享库的依赖关系，每个共享库都有一个对应的SO-NAME，这个SO-NAME即共享库的文件名去掉次版本号和发布版本号，保留主版本号。
  在linux系统中，系统会为每个共享库在他的目录创建一个跟SO-NAME相同的并且指向它的软链接

  > Glibc还是不符合这个规则，例如它的SO-NAME是libc.so.6,而对应的共享库一般是libc-2.6.1.so

  建立SO-NAME为名字的软链接的目的是，所有依赖某个共享库的模块，在编译、链接和运行时，都使用SO-NAME，而不是详细的版本号。
  SO-NAME保存在`.dynamic`段中，可使用`readelf -d`查看

  <img src=/images/共享库的组织/SO-NAME.png >

  `ldconfig `命令 
  用途主要是在默认搜寻目录/lib和/usr/lib以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如lib*.so*）,进而创建出动态装入程序(ld.so)所需的连接和缓存文件。缓存文件默认为/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令ldconfig，此执行程序存放在/sbin目录下。

  ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。
  其参数不过多介绍，一般默认执行即可，其最终目的就是根据动态库的SO-NAME创建对应的软链接和缓存文件，注意点:
  + 往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到。
  + 想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到。
  + 比如安装了一个mysql到/usr/local/mysql，mysql有一大堆library在/usr/local/mysql/lib下面，这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后ldconfig一下，新的library才能在程序运行时被找到。
  + 如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。
  + ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L就得加，不要混淆了。
  + 总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。
  + 再有，诸如libdb-4.3.so文件头中是会含有库名相关的信息的（即含“libdb-4.3.so”，可用strings命令察看），因此仅通过修改文件名以冒充某已被识别的库（如libdb-4.8.so）是行不通的。为此可在编译库的Makefile中直接修改配置信息，指定特别的库名。

4. 符号版本
  在动态链接时，只进行了主版本号的判断，即只判断SO-NAME，但是次版本只向后兼容，若依赖高的次版本的程序运行在低的次版本号的共享库系统时，可能产生缺少某些符号的错误，这种次版本号交会问题,使用符号版本机制。

  简单说就是让每个导入和导出的符号都有一个相关联的版本号，类似于符号的名称修饰

  linux下对于符号版本机制并没有广泛应用，是要在Glibc软件包中的共享库，比如我们能在程序中看到GLIBC_2.4等字眼就是

#  **共享库查找过程**

动态链接器会在/lib,/usr/lib和/etc/ld.so.conf文件中指定的目录下查找共享库，而每次遍历是很耗时的，所以使用ldconfig命令（前面提到过，且该命令在系统启动时会自动执行），在/etc/ld.so.cache中建立了一个SO-NAME的缓存，这样动态链接器就可以直接从中查找，若还是找不到还会遍历/lib和/usr/lib

动态库执行时搜索路径顺序:
1. 编译目标代码时指定的动态库搜索路径（-R参数）
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径
3. 缓存文件/etc/ld.so.cache中指定的路径
4. 默认的动态库搜索路径/usr/lib
5. 默认的动态库搜索路径/lib

不过LD_LIBRARY_PATH的设定作用是全局的，过多的使用可能会影响到其他应用程序的运行，所以多用在调试。（LD_LIBRARY_PATH 的缺陷和使用准则，可以参考《Why LD_LIBRARY_PATH is bad》 ）。通常情况下推荐还是使用gcc的-R或-rpath选项来在编译时就指定库的查找路径，并且该库的路径信息保存在可执行文件中，运行时它会直接到该路径查找库，避免了使用LD_LIBRARY_PATH环境变量查找

> LD_LIBRARY_PATH也会影响GCC编译时链接库的路径，即-L参数，顺序位于-L所指定的目录之后(没有-L选项当然也会搜索)


#  **共享库的创建**

使用-shared和-fPIC参数，作用前面已经介绍过了,另外还有一个参数是-Wl，可将指定的参数传递给链接器，例如:
`-Wl，-soname，mysoname`可以指定该共享库的SO-NAME，
若没有指定，则该共享库默认就没有SO-NAME，ldconfig命令就无法为其创建软链接








