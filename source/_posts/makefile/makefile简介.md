---
title: makefile简介
date: 2020-07-15 10:36:32
tags:
  - makefile
categories:
  - makefile
---


# 目录

+ 概述
+ 如何工作
+ makefile中有什么
+ 文件名
+ 引用其他makefile
+ 环境变量
+ 工作方式

<!--------more------->


#  **概述**

> 该系列笔记参考《跟我一起写makefile》,目前该笔记仅记录工作中有经常遇到的内容，有待补充

在讲述Makefile 之前，还是让我们先来粗略地看一看 Makefile 的规则。
```makefile
target ... : prerequisites ... 
command 
```

+ `target` 也就是一个目标文件，可以是 Object File，也可以是执行文件。还可以是一个 
标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述

+ `prerequisites` 就是要生成那个 `target` 所需要的文件或是目标。 
+ `command` 也就是make需要执行的命令（任意的 Shell 命令）。

这是一个文件的依赖关系，也就是说`target`这一个或多个的目标文件依赖于`prerequisites`中的文件，其生成规则定义在`command`中。说白一点就是说，`prerequisites`中如果有一个以上的文件比`target`文件要新的话，`command`所定义的命令就会被执行。这就是 Makefile 的规则。

> 依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。

在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个`Tab` 键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较`targets`文件和`prerequisites`文件的修改日期，如果`prerequisites`文件的日期要比`targets`文件的日期要新，或者`target`不存在的话，那么make 就会执行后续定义的命令。 


#  **如何工作**

在默认的方式下，也就是我们只输入 make 命令。那么
1. make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。 
2. 如果找到，它会找文件中的第一个目标文件（假设为all），并把这个文件作为最终的目标文件。 
3. 如果 all 文件不存在，或是 all 所依赖的后面的 .o 文件的文件修改时间要比 all这个文件新，那么，他就会执行后面所定义的命令来生成 all 这个文件。 
4. 如果 all 所依赖的.o 文件也不存在，那么 make 会在当前文件中找目标为.o 文件的依赖性，如果找到则再根据那一个规则生成.o 文件.（这有点像一个堆栈的过程） 
5. 当然，你的 C 文件和 H 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生命 make 的终极任务，也就是执行文件 all了。

这就是整个 make 的依赖性，make 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出并报错，而对于所定义的命令的错误，或是编译不成功，make 根本不理。make 只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。

#  **makefile中有什么**

1. 显式规则
	显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。

2. 隐晦规则
	由于make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile。

3. 变量定义
	在Makefile中我们定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。

4. 文件指示
	其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像 C 语言中的`include`一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译`#if`一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。

5. 注释
	Makefile中只有行注释，和Shell脚本一样，其注释是用“#”字符，这个就像 C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。

>  Makefile 中的命令，必须要以 Tab 键开始。


#  **文件名**

默认的情况下，make 命令会在当前目录下按顺序找寻文件名为`“GNUmakefile”、“makefile”、“Makefile”`的文件，找到了解释这个文件。在这三个文件名中，最好使用`“Makefile”`这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用`“GNUmakefile”`，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感。
当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，如果要指定特定的Makefile，你可以使用make的`“-f”和“--file”`参数，如：`make -f Make.Linux`。


#  **引用其他的makefile**

在 Makefile 使用`include`关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： 
`include <filename> `
filename可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符）在include前面可以有一些空字符，但是绝不能是Tab键开始。include 和<filename>可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么下面的语句： 
```makefile
include foo.make *.mk $(bar) 
```

等价于： 

```makefile
include foo.make a.mk b.mk c.mk e.mk f.mk 
```

make命令开始时，会把找寻`include`所指出的其它Makefile，并把其内容安置在当前的位置。如果文件都没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个目录下找： 

1. 如果 make 执行时，有“-I”或“--include-dir”参数，那么 make 就会在这个参数所指定的目录下去寻找。 
2. 如果目录<prefix>/include（一般是：/usr/local/bin 或/usr/include）存在的话，make 也会去找。

如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找 到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”，
如： 

```makefile
-include <filename> 
```

其表示，无论 include 过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。 


#  **环境变量**

如果你的当前环境中定义了环境变量MAKEFILES，那么make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的 Makefile 的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。
 
但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用 make 时，所有的 Makefile 都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的 Makefile 出现了怪事，那么你可以看看当前环境中有没有定义这个变量。


#  **工作方式**

+ 读入所有的 Makefile。 
+ 读入被 include 的其它 Makefile。 
+ 初始化文件中的变量。 
+ 推导隐晦规则，并分析所有规则。 
+ 为所有的目标文件创建依赖关系链。 
+ 根据依赖关系，决定哪些目标要重新生成。 
+ 执行生成命令。 



