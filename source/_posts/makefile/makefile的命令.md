---
title: makefile的命令
date: 2020-07-15 11:59:32
tags:
  - makefile
categories:
  - makefile
---


# 目录

+ 显示命令
+ 命令执行
+ 命令出错
+ 定义命令包

<!--------more------->

#  **显示命令**
1. 通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：
	``` 
	@echo 正在编译 XXX 模块...... 
	```
2. 如果 make 执行时，带入 make 参数`-n或--just-print`，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 

3. 而make参数`-s或--slient`则是全面禁止命令的显示。

#  **命令执行**
当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令，且写在同一行:

示例一：
``` makefile
exec: 
cd /home/hchen 
pwd
```

示例二：
``` makefile
exec: 
cd /home/hchen; pwd
```

在示例一中cd命令未生效

#  **命令出错**

每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令,有些时候，命令的出错并不表示就是错误的，为了忽略命令的出错，在命令行前加一个`-`,例如：

```makefile
clean: 
	-rm -f *.o 

```

还有一个全局的办法是，给make加上`-i`或是`--ignore-errors`参数，那么Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。

还有一个要提一下的make的参数的是`-k`或是`--keep-going`，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。

#  **定义命令包**

如果 Makefile 中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以`define`开始，以`endef`结束，例如： 

```
define run-yacc 
yacc $(firstword $^) 
mv y.tab.c $@ 
endef 
```

这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名，在 `define”和endef`中的两行就是命令序列，调用方式如下：

```
foo.c : foo.y 
$(run-yacc)
```
